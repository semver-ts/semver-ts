<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Variance in TypeScript - Semantic Versioning for TypeScript Types</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../styles/open-in.css">


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Semantic Versioning for TypeScript Types</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/semver-ts/semver-ts" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="appendix-c-variance-in-typescript"><a class="header" href="#appendix-c-variance-in-typescript">Appendix C: Variance in TypeScript</a></h1>
<p>As alluded to in <a href="../formal-spec/index.html#variance"><strong>Formal Specification: Variance</strong></a>, there are several complicating factors for the discussion of variance in TypeScript:</p>
<ul>
<li><a href="#inference-and-pervasive-mutability">Inference and pervasive mutability</a></li>
<li><a href="#structural-typing">Structural typing</a></li>
<li><a href="#higher-order-type-operations">Higher-order type operations</a></li>
</ul>
<h2 id="inference-and-pervasive-mutability"><a class="header" href="#inference-and-pervasive-mutability">Inference and pervasive mutability</a></h2>
<p>For example, by the classic rules, <code>Array&lt;T&gt;</code> should be invariant: it is a read-write (i.e. mutable) type. That means that a very simple change, otherwise apparently safe for consumers, can break it. Start with a library function which returns <code>string | number</code>:</p>
<pre><code class="language-ts">declare function example(): string | number;
</code></pre>
<p>A consumer might use this code in the construction of an array, and then having leaned on inference, push both <code>string</code>s and <code>number</code>s into it:</p>
<pre><code class="language-ts">const myArray = [example()]; // Array&lt;string | number&gt;
myArray.push(123);           // ✅
myArray.push("hello");       // ✅
</code></pre>
<p>The author of the library might later update <code>example</code> to return only <code>string</code>s:</p>
<pre><code class="language-ts">declare function example(): string;
</code></pre>
<p>This would be safe under the rule for write-only types, which is the intuition underlying many of the definitions below—but for our array example, it is <em>not</em> safe: <code>.push()</code>-ing in a <code>number</code> is now illegal.</p>
<pre><code class="language-ts">const myArray = [example()]; // Array&lt;string&gt;
myArray.push(123);           // ❌ number not assignable to string
myArray.push("hello");       // ✅
</code></pre>
<p>What's more, we don't need an object like an array to trigger this kind of behavior. Using a <code>let</code> binding instead of a <code>const</code> binding will produce exactly the same issue. Under the original definition of <code>example</code>, this would be perfectly legal:</p>
<pre><code class="language-ts">let value = example(); // string | number
value = 123;           // ✅
value = "hello";       // ✅
</code></pre>
<p>But it stops being valid as soon as <code>example</code> is narrowed:</p>
<pre><code class="language-ts">let value = example(); // string
value = 123;           // ❌ number not assignable to string
value = "hello";       // ✅
</code></pre>
<p>While lint guidelines preferring <code>const</code> may <em>help</em> mitigate the latter, they are controversial<sup class="footnote-reference"><a href="#const-controversy">1</a></sup> and they do not and cannot help with the <code>Array</code> example or others like it. Nor is it feasible to require a “functional” immutable-update style, given that JavaScript lacks robust immutable data structures, which would allow for recommending that approach.</p>
<p>In this case, cautious users may work around this by explicitly annotating their types to match the return type of the:</p>
<pre><code class="language-ts">const myArray: Array&lt;string | number&gt; = [example()];
let value: string | number = example();
</code></pre>
<p>We do not expect this to be common, however: the cost of this is much higher than the cost of changing one's code in the cases where it may be broken.</p>
<h2 id="structural-typing"><a class="header" href="#structural-typing">Structural typing</a></h2>
<p>Most programming languages where programmers must deal with variance have <em>nominal</em> type systems, and subtyping relations can be straightforwardly specified in terms of the relations between the types—particular via subclassing (as in Java, C++, and C#) or between interfaces (as in Rust’s <code>trait</code> system). In TypeScript, however, subtyping relationships include both subclassing and interface-based subtypes and also <em>structural subtyping</em>.</p>
<p>Given types <code>A</code> and <code>B</code>, <code>B</code> is a subtype of <code>A</code> for the purposes of assignability (e.g. in function calls) when it is a <em>superset</em> of <code>A</code>. Most simply:</p>
<pre><code class="language-ts">type A = {
  a: number;
}

type B = {
  a: number;
  b: string;
}

type C = {
  a?: number;
  b: string;
}

declare function takesA(a: A): void;

declare let a: A;
declare let b: B;
declare let c: C;
takesA(a); // ✅
takesA(b); // ✅
takesA(c); // ❌
</code></pre>
<p>Notice that this is <em>unlike</em> the dynamics in nominal type systems, where unless <code>B</code> explicitly declared a relationship to <code>A</code> (e.g. <code>class B extends A { }</code> or <code>interface B : A { }</code> or similar), the two are unrelated, regardless of their structural relationships. Similar dynamics play out for other kinds of types.</p>
<h2 id="higher-order-type-operations"><a class="header" href="#higher-order-type-operations">Higher-order type operations</a></h2>
<p>The second factor which makes dealing with TypeScript types difficult is its support for <em>type-level mutation</em>. Consider the type of <code>x</code> at points 1–4 in the following simple, but relatively idiomatic, TypeScript function definition:</p>
<pre><code class="language-ts">function describe(x: string | number | undefined) {
  switch (typeof x) {                 // 1
    case 'string':
      return `x is the string ${x}`;  // 2
    case 'number':
      return `x is the number ${x}`;  // 3
    default:
      return `x is "undefined"`;      // 4
  }
}
</code></pre>
<ol>
<li>The type is <code>string | number | undefined</code>.</li>
<li>The type is <code>string</code>.</li>
<li>The type is <code>number</code>.</li>
<li>The type is <code>undefined</code>.</li>
</ol>
<p>While this quickly becomes second-nature to TypeScript developers and we don’t give it a second thought, it’s important to take a step back and consider what is actually happening here: the type of <code>x</code> is a variable—a <em>type-level</em> variable—whose value changes over the body of the function. That is, it is a <em>mutable type-level variable</em>. While it is possible to construct values whose types in TypeScript are <em>not</em> mutable (e.g. with <code>never</code> or a boolean or numeric literal value), <em>most</em> values constructed in an ordinary TypeScript program have mutable types.</p>
<p>What’s more, this combines with TypeScript’s use of structural typing and inference mean that many cases which would intuitively be “safe” to make changes around can in fact create compiler errors. For example, consider a function which today returns <code>string | number</code>:</p>
<pre><code class="language-ts">declare function a(): string | number;
</code></pre>
<p>Using this function to create a value <code>x</code> will give us the type <code>x: string | number</code> as we would expect. Then we might <em>narrow</em> the type later:</p>
<pre><code class="language-ts">const x = a(); // string | number
const y = typeof x === 'string' ? x.length : x;  // ✅
</code></pre>
<p>In general by the rules of variance, we would expect that narrowing the return type of <code>a</code> to always return <code>number</code> would be fine. This is in a “write-only” position, and so we would expect that we should allow contravariance: a narrower type is permissible. From a runtime perspective, that is true, because all existing code will continue to work (even if there are some unnecessary branches). However, TypeScript will produce a type error here, because the type of <code>x</code> no longer includes <code>string</code>, and so the <code>typeof x === 'string'</code> check can be statically known to be.</p>
<p>Practically speaking, this is an annoyance rather than a meaningful breaking change. It can, however, result in significant work across a code base! What is more, it is not possible to work around this merely with an explicit type definition today. Naïvely, we might expect explicit type declarations to allow us to dodge this problem in places we actually care about it:</p>
<pre><code class="language-ts">const x: string | number = a();
const y = typeof x === 'string' ? x.length : x;  // ❌
</code></pre>
<p>In practice, however, TypeScript today (up through 4.5) will first check that the type returned by <code>a()</code> is a subtype of the declared type of <code>x</code>, and then if <code>a()</code> returns a <em>narrower</em> type than that declared for <code>x</code>, it will actually set <code>x</code>'s type to the narrower type returned by <code>a()</code> instead of the explicitly-declared type. Thus, a user who wishes to avoid this problem must <em>everywhere</em> annotate their code with explicit type casts:</p>
<pre><code class="language-ts">const x = a() as string | number;
const y = typeof x === 'string' ? x.length : x;
</code></pre>
<p>This is very annoying; worse, it is also easy to break. TypeScript today silently allows an unsafe cast here, which can in turn produce runtime errors:</p>
<pre><code class="language-ts">declare function a(): string | number;
const x = a() as string; // 👎🏼
const y = x.length;  // possible runtime error!
</code></pre>
<p>Thus, for the thoroughly pragmatic reason that no one would ever want to write these kinds of casts and the more principled reason that these kinds of casts as readily undermine as support the kinds of type safety TypeScript aims to provide <em>and</em> the versioning guarantees this specification aims to provide, we simply acknowledge that from a practical standpoint, the pervasiveness of type-level mutation makes it impossible to provide a definition of breaking changes which forbids the introduction of compiler errors by even apparently-safe changes.</p>
<p>The problem runs the other direction, too: while this example shows now-extraneous code which can be deleted, the same underlying issue can also require <em>adding</em> code, e.g. when adding a field to a library type which was previously being used to discriminate two objects.</p>
<p>Given this starting code:</p>
<pre><code class="language-ts">// provided by the library
type LibType = {
  a: boolean;
}

type MyType = {
  b: string;
}

function takesEither(obj: LibType | MyType) {
  if ('b' in obj) {
      // narrowed obj to `MyType`
    console.log(obj.b.substring(0));
  }
}
</code></pre>
<p>If the library adds a field <code>b</code> which is of any type but <code>string</code>—</p>
<pre><code class="language-ts">type LibType = {
  a: boolean;
  b: number;
}
</code></pre>
<p>—then we have a type error in <code>takesEither()</code> because the <code>in</code> operator no longer successfully discriminates between <code>LibType</code> and <code>MyType</code>:</p>
<pre><code class="language-ts">function takesEither(obj: LibType | MyType) {
  if ('b' in obj) {
    // `obj` is still `LibType | MyType` so `b` is now `string | number`
    console.log(obj.b.substring(0)); // ❌
  }
}
</code></pre>
<p>The compiler will dutifully report:</p>
<blockquote>
<p>Property 'substring' does not exist on type 'string | number'.</p>
</blockquote>
<p>In sum, just as pervasive runtime mutability and inference made it impossible to fully specify an approach which prevents users from experiencing breaking changes.</p>
<div class="footnote-definition" id="const-controversy"><sup class="footnote-definition-label">1</sup>
<p>Rightly so, in our opinion!</p>
</div>
<footer id="open-on-gh">Suggestions welcome! <a href="https://github.com/semver-ts/semver-ts/edit/main/src/appendices/c-variance-in-typescript.md">Edit this page on GitHub.</a></footer>
                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../appendices/b-tooling.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../appendices/d-history.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../appendices/b-tooling.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../appendices/d-history.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
